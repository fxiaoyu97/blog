(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{363:function(t,v,e){"use strict";e.r(v);var _=e(42),r=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"撤销已经执行操作的文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#撤销已经执行操作的文件"}},[t._v("#")]),t._v(" 撤销已经执行操作的文件")]),t._v(" "),e("h2",{attrs:{id:"已经add的文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#已经add的文件"}},[t._v("#")]),t._v(" 已经add的文件")]),t._v(" "),e("p",[t._v("众所周知，Git把文件划分为三个区，分别是工作区、暂存区和本地仓库，那么add后的文件已经提交到暂存区了，这时候我们想要把add后的文件的还原到未添加以前的操作，那么我们该怎么办呢？")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("如果还想保留修改内容的话，可以直接使用下面的命令把文件从暂存区删除掉："),e("code",[t._v("git rm --cache -r 1.txt")]),t._v("，这时候还有点不一样的地方，")]),t._v(" "),e("ul",[e("li",[t._v("如果是新创建的文件，使用这个命令，可以直接从暂存区删除掉，转到工作区。")]),t._v(" "),e("li",[t._v("如果是修改的文件，使用这个命令，那么文件会变成删除的状态，意思就是从本地仓库删除的意思，再执行一次commit，就会把文件从仓库删除掉，文件进入暂存区，文件修改的内容不会改变。")])])]),t._v(" "),e("li",[e("p",[t._v("如果不需要保留修改内容的话，可以直接使用版本还原命令："),e("code",[t._v("git reset --hard <版本号>")]),t._v("，例如"),e("code",[t._v("git reset --hard c5775")]),t._v("(版本号一般写5位即可，要保证填写的这几位不出现重复即可)，特别特别注意，正如它的名字一样，这是很硬核的命令，"),e("strong",[t._v("这里会把整个工作区撤销到某个版本，会把这个版本以后你新增或者修改的内容全部删除掉，回收站和本地仓库都找不来的那种。")]),t._v(" 比较有意思的一点是未添加到版本控制的文件（即那些未执行add操作的文件不会被删除）。")])])]),t._v(" "),e("h2",{attrs:{id:"已经commit的文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#已经commit的文件"}},[t._v("#")]),t._v(" 已经commit的文件")]),t._v(" "),e("p",[t._v("这时候的文件已经进入本地仓库了，这时候的撤销就会出现不同的情况了，是要撤销到暂存区还是工作区呢？这时候多了不同的选择，具体的操作接着往下看。")]),t._v(" "),e("ol",[e("li",[t._v("撤销文件到暂存区，这时"),e("strong",[t._v("只是撤销commit的操作")]),t._v("，对应的命令是："),e("code",[t._v("git reset --soft <版本号>")]),t._v("(例如"),e("code",[t._v("git reset --soft c5775")]),t._v(")，此时你会发现对应的文件被撤销了，但是修改内容还是存在的，并且文件在暂存区，此时如果你想再撤销add操作的话，可以参考第一种情况。")]),t._v(" "),e("li",[t._v("撤销文件到工作区，如果需要删除工作区改动的内容的话，可以使用命令："),e("code",[t._v("git reset --hard <版本号>")]),t._v("(例如"),e("code",[t._v("git reset --hard c5775")]),t._v(")，正如第一种情况中提到的，在"),e("strong",[t._v("撤销commit操作的同时会撤销add操作，并且把你修改和新增的内容全部删除掉")]),t._v("，可以试着先撤销到最近提交的版本，这样可以把文件的变动降低到最小。")]),t._v(" "),e("li",[t._v("撤销文件到工作区，并"),e("strong",[t._v("保留修改的内容，然后撤销commit，撤销add操作")]),t._v("，这时候就要使用另外一个命令参数了："),e("code",[t._v("git reset --mixed <版本号>")]),t._v("(例如"),e("code",[t._v("git reset --mixed c5775")]),t._v(")，此时该版本后面的的commit和add都会被撤回的，但是修改以后的内容并没有被删除掉。\n"),e("ul",[e("li",[t._v("所有新创建的文件都会回到工作区")]),t._v(" "),e("li",[t._v("所有提交后修改的文件会到暂存区")]),t._v(" "),e("li",[t._v("所有在这个版本以后提交并修改的文件，会回到工作区，并且修改内容不变。")]),t._v(" "),e("li",[e("strong",[t._v("默认情况下，"),e("code",[t._v("git reset")]),t._v("后面不跟参数时，使用的是"),e("code",[t._v("--mixed")])])])])])]),t._v(" "),e("p",[e("strong",[t._v("拓展知识：只修改提交的说明内容")])]),t._v(" "),e("p",[t._v("如果只是提交时的说明内容写错了，那么可以使用另外一条命令进行修改："),e("code",[t._v("git commit --amend")]),t._v("，这条命令不需要跟版本号，只会修改最近一次commit的说明内容，执行以后会进入vim编辑器，后面的操作同vim的基础操作。")]),t._v(" "),e("h2",{attrs:{id:"已经push的文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#已经push的文件"}},[t._v("#")]),t._v(" 已经push的文件")]),t._v(" "),e("p",[t._v("执行push的文件已经进入远程仓库，突然发现文件提交错了，这是不是感觉比较慌？不用紧张，当你掌握了前面的那些操作以后，你会发现此时的操作也没那么难嘛。")]),t._v(" "),e("p",[t._v("改变远程仓库的文件只要两步，首先撤销本地仓库的修改，然后推送到远程仓库即可。但是，这时候会遇到一个问题。")]),t._v(" "),e("p",[t._v("因为执行撤销操作以后，导致本地的版本号低于远程仓库的版本号，这时候执行推送的操作就会变错。就需要我们执行强制推送，命令如下所示：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("git push origin <分支名> –force （例如：git push origin master –force ）")])]),t._v(" "),e("li",[t._v("或者使用："),e("code",[t._v("git push -f origin master")])])]),t._v(" "),e("h2",{attrs:{id:"git-reset-和-git-revert"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset-和-git-revert"}},[t._v("#")]),t._v(" git reset 和 git revert")]),t._v(" "),e("p",[t._v("revert可以理解为复原，相当于对某些操作的逆转。关于"),e("code",[t._v("git revert")]),t._v("有以下几个注意点：")]),t._v(" "),e("ul",[e("li",[t._v("基本的使用操作是"),e("code",[t._v("git revert <版本号>")]),t._v("，撤销某次提交")]),t._v(" "),e("li",[e("code",[t._v("git revert")]),t._v("操作会产生一次新的commit")])]),t._v(" "),e("p",[e("strong",[t._v("我们可不可以只产生一次新的commit完成批量撤销复原操作呢？")])]),t._v(" "),e("p",[t._v("嘿嘿，这也是可以的。撤销一串提交可以使用的命令是："),e("code",[t._v("git revert --no-commit <commit1>..<commit2>")]),t._v("，"),e("strong",[t._v("这是一个前开后闭的区间选择")]),t._v("，意思就是不包括commit1，但包括commit2。这个是连续性，会把"),e("code",[t._v("commit1")]),t._v("和"),e("code",[t._v("commit2")]),t._v("之间所有的修改都撤销了，包括"),e("code",[t._v("commit2t")]),t._v("提交记录的修改。而且revert对每个撤销的commit记录都会生成一个新的提交，产生一次提交记录。"),e("code",[t._v("--no-commit")]),t._v(" 表示可以最后一起手动提交，避免产生太多提交记录。")]),t._v(" "),e("p",[t._v("那么问题又来了，"),e("strong",[t._v("如果你对某文件进行了多次修改，多次修改的是同一块代码，然后再撤销很久很久以前一次提交，那么会出现什么后果呢？")])]),t._v(" "),e("p",[t._v("这时候再使用revert的话，会出错的，提醒无法复原文件，但是git会把执行结果展示在文件中，git会把文件划分为两部分，**一部分包括文件现在的内容，一部分包括文件复原版本的上一个版本的内容。中间以"),e("code",[t._v("=======")]),t._v("划分。**最终的内容由用户自己决定。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<<<<<<< HEAD\n文件现在的内容\n=======\n文件在复原后，上一个版本的内容\n>>>>>>> parent of e686989... modify 2.txt\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("p",[t._v("修改完成以后，执行add和commit即可。")]),t._v(" "),e("hr"),t._v(" "),e("p",[e("code",[t._v("git reset")]),t._v(" 和"),e("code",[t._v("git revert")]),t._v("的区别可以用一句话概括下来："),e("code",[t._v("git reset --hard")]),t._v(" 撤销"),e("font",{attrs:{color:"red"}},[t._v("到")]),t._v("某次提交，"),e("code",[t._v("git revert")]),t._v("撤销某次提交 。")],1)])}),[],!1,null,null,null);v.default=r.exports}}]);